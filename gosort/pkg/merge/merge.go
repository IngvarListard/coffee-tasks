package merge

/*
Сложность алгоритма n * log(n), т.к. у нас есть log(n) операций над n элементов в массиве
*/

func merge(left, right []int) []int {
	/*
		Тут вродебы также подразумевается, что левый и правый списки приходят отсортированными
		но первая итерация будет происходит с самыми простейшими списками, например [1], [2]

		Тут мы просто рассматриваем каждый элемент массива и сравниваем его их по одному элементу до тех пор
		пока в одном из массивов не останется элементов.
		Когда слияние закончится, нужно проверить, остались ли элементы в левом или в правом
	*/

	list := make([]int, 0)
	for len(left) > 0 && len(right) > 0 {
		// если правый элемент больше чем левый, то добавляем левый элемент в массив, т.к. сортируем от большего
		// к меньшему
		if left[0] < right[0] {
			list = append(list, left[0])
			left = left[1:]
		} else {
			// если левый элемент больше, то добавляем правый, и удаляем его из исходного слайса
			list = append(list, right[0])
			right = right[1:]
		}
	}

	// если массивы разных размеров, просто добавляем остаток в результирующий массив
	// т.к. предполагается что приходящие массивы уже отсортированы
	if len(left) > 0 {
		list = append(list, left...)
	}
	if len(right) > 0 {
		list = append(list, right...)
	}
	return list
}

func MergeSort(list []int) []int {
	/*
		сначала проверяем, если длина списка == 1 => список отсортирован. Возвращаем его.
		Если нет, ищем индекс середины этого списка

		Предполагается, что функция mergesort должна возвращать отсортированный список.
		Сортирует она с помощью рекурсивного вызова самой себя, каждый раз деля список
		пополам, делит его до тех пор, пока в списке не останется два элемента
		А два элемента уже можно легко сравнить и отсортировать "на месте"

		Значит в функцию мержа передаем сначала левую часть списка, потом правую,
		подразумевая что merge вернет уже осортированный список
	*/

	length := len(list)
	if length <= 1 {
		return list
	}

	mid := length / 2
	list = merge(MergeSort(list[:mid]), MergeSort(list[mid:]))

	return list
}
